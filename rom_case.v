// auto generated from http://users.rowan.edu/~haskellt8/assembler/
module rom_case(out, address);
	output reg [31:0] out;
	input  [15:0] address; // address- 16 deep memory  
	always @(address) begin
		case (address)
		
16'h0000:  out = 32'b10010001001110100110011111100100; // ADDI X4, XZR, 3737
16'h0001:  out = 32'b11010011011000001101000010010100; // LSL X20, X4, 52
16'h0002:  out = 32'b10010001000110010101011111100111; // ADDI X7, XZR, 1621
16'h0003:  out = 32'b11010011011000001010000011101000; // LSL X8, X7, 40
16'h0004:  out = 32'b10001011000010000000001010010100; // ADD X20, X20, X8
16'h0005:  out = 32'b10010001000101010101011111101001; // ADDI X9, XZR, 1365
16'h0006:  out = 32'b11010011011000000111000100101010; // LSL X10, X9, 28
16'h0007:  out = 32'b10001011000101000000000101010100; // ADD X20, X10, X20
16'h0008:  out = 32'b10010001001101100101011111101011; // ADDI X11, XZR, 3477
16'h0009:  out = 32'b11010011011000000100000101101100; // LSL X12, X11, 16
16'h000a:  out = 32'b10001011000101000000000110010100; // ADD X20, X12, X20
16'h000b:  out = 32'b10010001001101010101011111101101; // ADDI X13, XZR, 3413
16'h000c:  out = 32'b11010011011000000001000110101110; // LSL X14, X13, 4
16'h000d:  out = 32'b10001011000011100000001010010100; // ADD X20, X20, X14
16'h000e:  out = 32'b10010001000000000001101111101111; // ADDI X15, XZR, 6
16'h000f:  out = 32'b10001011000101000000000111110100; // ADD X20, X15, X20
16'h0010:  out = 32'b11111000000000001111001111110100; // STUR X20, [XZR, 15]
16'h0011:  out = 32'b11111000010000001111001111111001; // LDUR X25, [XZR, 15]

		
/*		16'h0000:  out = 32'b10010001001111110111011111100100; // ADDI X4, XZR, 4061
		16'h0001:  out = 32'b11010011011000001101000010010100; // LSL X20, X4, 52
		16'h0002:  out = 32'b10010001000110010101011111100111; // ADDI X7, XZR, 1621
		16'h0003:  out = 32'b11010011011000001010000011101000; // LSL X8, X7, 40
		16'h0004:  out = 32'b10101010000010000000001010010100; // ORR X20, X20, X8
		16'h0005:  out = 32'b10010001000101010101011111101001; // ADDI X9, XZR, 1365
		16'h0006:  out = 32'b11010011011000000111000100101010; // LSL X10, X9, 28
		16'h0007:  out = 32'b10101010000101000000000101010100; // ORR X20, X10, X20
		16'h0008:  out = 32'b10010001001101100101011111101011; // ADDI X11, XZR, 3477
		16'h0009:  out = 32'b11010011011000000100000101101100; // LSL X12, X11, 16
		16'h000a:  out = 32'b10101010000101000000000110010100; // ORR X20, X12, X20
		16'h000b:  out = 32'b10010001001101010101011111101101; // ADDI X13, XZR, 3413
		16'h000c:  out = 32'b11010011011000000001000110101110; // LSL X14, X13, 4
		16'h000d:  out = 32'b10101010000011100000001010010100; // ORR X20, X20, X14
		16'h000e:  out = 32'b10010001000000000001101111101111; // ADDI X15, XZR, 6
		16'h000f:  out = 32'b10101010000101000000000111110100; // ORR X20, X15, X20
		16'h0010:  out = 32'b11111000000000001111001111110100; // STUR X20, [XZR, 15]
		16'h0011:  out = 32'b11111000010000001111001111111001; // LDUR X25, [XZR, 15]*/
		
/*			// GPIO test
			16'h0000:  out = 32'b11010010100000000000000000100000; // MOVZ X0, 1
			16'h0001:  out = 32'b11010011011000000111000000000000; // LSL X0, X0, 28
			16'h0002:  out = 32'b11010010100000000111111111100001; // MOVZ X1, 1023
			16'h0003:  out = 32'b11111000000000001000000000000001; // STUR X1, [X0, 8]
			16'h0004:  out = 32'b11111000010000000000000000000010; // LDUR X2, [X0, 0]
			16'h0005:  out = 32'b11010011010000000010100001000010; // LSR X2, X2, 10
			16'h0006:  out = 32'b11111000000000000000000000000010; // STUR X2, [X0, 0]
			16'h0007:  out = 32'b00010111111111111111111111111100; // B -4*/

/* 		// core test 
			16'h0000:  out = 32'b11010010100000000000000000100001; // MOVZ X1, 1
			16'h0001:  out = 32'b11010010100000000000000001000010; // MOVZ X2, 2
			16'h0002:  out = 32'b10001011000000100000000000100100; // ADD X4, X1, X2
			16'h0003:  out = 32'b11111000000000010000001111100100; // STUR X4, [XZR, 16]
			16'h0004:  out = 32'b11111000010000010000001111100101; // LDUR X5, [XZR, 16]
			16'h0005:  out = 32'b10010100000000000000000000001010; // BL 10
			16'h0006:  out = 32'b10110101000000000000000000100010; // CBNZ X2, 1
			16'h0007:  out = 32'b00010100000000000000000000000001; // B 1
			16'h0008:  out = 32'b00010111111111111111111111111001; // B -7
			16'h0009:  out = 32'b10110100000000000000000001100001; // CBZ X1, 3
			16'h000a:  out = 32'b11101011000000100000000000111111; // SUBS XZR, X1, X2
			16'h000b:  out = 32'b01010100000000000000000000100011; // B.LO 1
			16'h000c:  out = 32'b11111000000000001000001111100001; // STUR X1, [XZR, 8]
			16'h000d:  out = 32'b11111000010000001000001111100110; // LDUR X6, [XZR, 8]
			16'h000e:  out = 32'b11010010000000000000010011100111; // EORI X7, X7, 1
			16'h000f:  out = 32'b00010111111111111111111111111110; // B -2
			16'h0010:  out = 32'b10010001000000000000100000100001; // ADDI X1, X1, 2
			16'h0011:  out = 32'b11010001000000000000010001000010; // SUBI X2, X2, 1
			16'h0012:  out = 32'b11010110000000000000001111000000; // BR X30
			*/
			default: out=32'hD60003E0; //BR XZR
		endcase
	end
endmodule

/*
C code for above asm:
X1 = 1;
X2 = 2;
while(1) {
	X4 = X1 + X2;
	M[16] = X4;
	X5 = M[16];
	IncDec();
	if(X2 == 0) {
		break;
	}
}
if(X1 != 0) {
	if(X1 > X2) {
		M[8] = X1;
	}
}
X6 = M[8]
while(1){
	X7 = X7 ^ 1;
}

void IncDec(void) {
	X1 = X1 + 1;
	X2 = X2 - 1
}
*/
